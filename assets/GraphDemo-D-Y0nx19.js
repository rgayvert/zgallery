var w=Object.defineProperty;var b=(i,e,t)=>e in i?w(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var h=(i,e,t)=>(b(i,typeof e!="symbol"?e+"":e,t),t);import{aK as E,v as F,a as u,g as v,k as d,ad as D,p as x,c as p,V as y,aL as G,H as M,h as W,f as j,G as k}from"./index-DCW3DhvE.js";import{A as I}from"./AnimationModel-BABCDtKd.js";class g{constructor(e,t){h(this,"adjacentVertices",new Set);this.id=e,this.data=t}toString(){return`<${this.id}>`}addEdge(e){this.adjacentVertices.add(e.vertex1===this?e.vertex2:e.vertex1)}removeEdge(e){this.adjacentVertices.delete(e.vertex1===this?e.vertex2:e.vertex1)}}function O(i,e){return i[0]===e[0]&&i[1]===e[1]||i[0]===e[1]&&i[1]===e[0]}class l{constructor(e,t,a){this.vertex1=e,this.vertex2=t,this.data=a,e.addEdge(this),t.addEdge(this)}containsVertex(e){return e===this.vertex1||e===this.vertex2}containsVertices(e,t){return O([this.vertex1.id,this.vertex2.id],[e.id,t.id])}toString(){return`[${this.vertex1.id} -> ${this.vertex2.id}]`}}class m{constructor(e,t=[],a=!1){this.vertices=e,this.edges=t,this.isDirected=a}vertexWithID(e){return this.vertices.find(t=>t.id===e)}addVertex(e){this.vertices.push(e)}addEdge(e){this.edges.push(e),e.vertex1.addEdge(e),e.vertex2.addEdge(e)}addEdgeWithIDs(e,t,a){this.addEdgeWithVertices(this.vertexWithID(e),this.vertexWithID(t))}addEdgeWithVertices(e,t,a){e&&t&&this.addEdge(new l(e,t,a))}edgeWithVertices(e,t){return this.edges.find(a=>a.containsVertex(e)&&a.containsVertex(t))}findShortestPath(e,t){const a=[],s=new Set,r=new Map,n=new Map;for(n.set(e,0),a.push(e);a.length>0;){const c=a.shift();[...c.adjacentVertices].forEach(o=>{s.has(o)||(a.push(o),s.add(o),r.has(o)||r.set(o,c),n.has(o)||n.set(o,n.get(c)+1))})}if(r.has(t)){const c=[t];let o=r.get(t);for(c.push(o);o!==e;)o=r.get(o),c.push(o);return c.reverse().map(V=>V.id)}else return[]}}const P={size:E(200,200),gravity:1,repulsion:100,springSize:.5,stepSize:.01,iterations:300};class f extends m{constructor(t,a,s={}){super(t,a);h(this,"config");h(this,"iterationCount",0);this.config=Object.assign({...P},s)}static fromGraph(t,a){const s=a.size||E(200,200),r=t.vertices.map(c=>new g(c.id,{location:this.randomPoint(s),force:F(0,0),mass:this.randomMass()})),n=t.edges.map(c=>new l(r.find(o=>o.id===c.vertex1.id),r.find(o=>o.id===c.vertex2.id)));return new f(r,n,a)}static randomPoint(t){return u(v(d.randomInt(-.45*t.x,.45*t.x),d.randomInt(-.45*t.y,.45*t.y)))}static randomMass(){return d.random(2,3)}applyForces(t,a){const s=a.data.location.get().subtract(t.data.location.get()),r=s.scalarMultiply(this.config.repulsion/s.magnitudeSquared());if(t.data.force=t.data.force.subtract(r),a.data.force=a.data.force.add(r),t.adjacentVertices.has(a)){const n=s.scalarMultiply(.1);t.data.force=t.data.force.add(n),a.data.force=a.data.force.subtract(n)}}step(t){d.repeatForMillis(16,()=>this.iterateOnce()),this.iterationCount++}iterateOnce(){const t=this.vertices;t.forEach(a=>a.data.force=a.data.location.get().scalarMultiply(-this.config.gravity));for(let a=0;a<t.length;a++)for(let s=a+1;s<t.length;s++)this.applyForces(t[a],t[s]);t.forEach(a=>{a.data.location.set(a.data.location.get().add(a.data.force.scalarMultiply(.2*a.data.mass)))})}}const S={graph:(i,e,t,a)=>{const s=d.sequence(0,i).map(n=>new g(n,t?{weight:d.random(t.start,t.end)}:{})),r=new m(s);for(;r.edges.length<e;){const n=d.randomSubset(s,2);r.edgeWithVertices(n[0],n[1])||r.addEdge(new l(n[0],n[1]))}return r.vertices.forEach(n=>{if(n.adjacentVertices.size===0){const c=d.randomElementMatching(r.vertices,o=>o!==n);c&&r.addEdge(new l(n,c))}}),r},weightedVertexGraph:(i,e,t)=>S.graph(i,e,t)};function q(){const i=S.graph(100,50,{start:1,end:5}),e=f.fromGraph(i,{iterations:50}),t=new I({duration:5e3});t.add(e);const a={bounds:D(-100,-100,200,200),width:x(400),height:x(400),fill:p.color.background,draggableElements:!0,edgeStrokeWidth:1,vertexRadius:s=>s.data.mass,onVertexDrag:()=>t.start()};return y({gap:p.space.s5}).append(G(e,a),M({gap:p.space.s3}).append(W({label:u(()=>t.isRunning?"Stop":"Start"),action:()=>t.startOrStop()})))}function z(){const i=[[10,10],[40,10],[40,30],[70,30]],e=[[0,1],[1,2],[2,3],[3,4]],t=d.sequence(0,4).map(s=>{const r={location:u(v(i[s][0],i[s][1]))};return new g(s,r)}),a=new m(t);return e.forEach(([s,r])=>a.addEdgeWithIDs(s,r)),G(a,{bounds:D(0,0,100,40),border:p.border.thin,draggableElements:!0,width:j(50)})}function R(){return k(A)}const A={sourceDir:"/source/Demos/Graphs",sections:[{title:"Simple Graph",componentFn:z,sources:["SimpleGraphExample.ts"],markdown:"SimpleGraphExample.md"},{title:"Force Directed Graph",componentFn:q,sources:["ForceDirectedGraphExample.ts"],markdown:"ForceDirectedGraphExample.md"}]};export{R as GraphDemo,R as default};
